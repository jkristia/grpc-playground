from __future__ import annotations
from google.protobuf.json_format import MessageToDict
from typing import Optional, List, Dict, Any, cast
import inspect
from enum import Enum
"""
    auto generated file, model classes generated from protobuf classes
    
    example of usage:
    
    from google.protobuf.json_format import MessageToDict
    # proto buf message
    pbMsg = pb2.MyMessage(...)
    # convert to autogenerated Model object
    modelMsg = ModelMyMessage.from_pb_msg(pbMsg)
"""

MODEL_VERSION = '0.0.1'


class ModelBase():
	def to_dict(self) -> Any:
		properties = [name for name, value in inspect.getmembers(self.__class__, inspect.isdatadescriptor)]
		d = {}
		for property in properties:
			if property.startswith('__'):
				continue
			d[property] = getattr(self, property)
		return self._to_dict(d)
	
	def _to_dict(self, obj) -> Any:
		# return enum name, not value
		if isinstance(obj, Enum):
			return obj.name
		if isinstance(obj, ModelBase) and obj != self:
			return obj.to_dict()
		# remove None values
		if isinstance(obj, list):
			return [self._to_dict(item) for item in obj if item is not None]
		if isinstance(obj, dict):
			return {key: self._to_dict(value) for key, value in obj.items() if value is not None }
		if isinstance(obj, Google_Timestamp) and obj != self:
			return obj.time
		else:
			return obj
		
	def after_serialize_in(self) -> Any:
		return self
		
	@classmethod
	def dict_from_pb_message(cls, pb_msg: Any) -> dict:
		return MessageToDict(pb_msg, always_print_fields_with_no_presence=True)



class Google_Timestamp():

	def __init__(self, time: str):
		self.time: str = time
	

### enum: module_a.BasicEnum
class ModuleA_BasicEnum(Enum):
	UNKNOWN = 'UNKNOWN'
	VALUE_1 = 'VALUE_1'
	ABC = 'ABC'
	LOWER_CASE_VALUE = 'lower_case_value'

### message: module_a.BasicSubItem
class ModuleA_BasicSubItem(ModelBase):
	CLASS_NAME = 'ModuleA_BasicSubItem'
	
	# protobuf names
	PB_NAME = 'name'
	PB_SINGLEPOINT = 'singlePoint'
	
	# json / dict names
	NAME = 'name'
	SINGLEPOINT = 'singlePoint'
	
	# property name
	@property
	def name(self) -> Optional[str]:
		return self._name
	@name.setter
	def name(self, value: Optional[str]):
		self._name = value
	
	# property singlePoint
	@property
	def singlePoint(self) -> Optional[ModuleA_SomePoint]:
		return self._singlePoint
	@singlePoint.setter
	def singlePoint(self, value: Optional[ModuleA_SomePoint]):
		self._singlePoint = value
	
	# constructor - ModuleA_BasicSubItem
	def __init__(self,
			name: Optional[str] = None,
			singlePoint: Optional[ModuleA_SomePoint] = None,
			):
		self._name = name
		self._singlePoint = singlePoint
		pass
	
	# serialization
	@classmethod
	def from_dict(cls, data: dict) -> 'ModuleA_BasicSubItem':
		return cls(**data).after_serialize_in()
	
	@classmethod
	def from_pb_msg(cls, pb_msg: Any) -> 'ModuleA_BasicSubItem':
		data = ModelBase.dict_from_pb_message(pb_msg)
		return cls(**data).after_serialize_in()
				   
	def after_serialize_in(self) -> 'ModuleA_BasicSubItem':
		if self.singlePoint is not None:
			raw: Any = self.singlePoint
			self.singlePoint = ModuleA_SomePoint(**raw).after_serialize_in()
		return self
	
	def clone(self) -> 'ModuleA_BasicSubItem':
		return ModuleA_BasicSubItem.from_dict(self.to_dict())
	pass
	
### message: module_a.SomePoint
class ModuleA_SomePoint(ModelBase):
	CLASS_NAME = 'ModuleA_SomePoint'
	
	# protobuf names
	PB_X = 'x'
	PB_Y = 'y'
	
	# json / dict names
	X = 'x'
	Y = 'y'
	
	# property x
	@property
	def x(self) -> Optional[float]:
		return self._x
	@x.setter
	def x(self, value: Optional[float]):
		self._x = value
	
	# property y
	@property
	def y(self) -> Optional[float]:
		return self._y
	@y.setter
	def y(self, value: Optional[float]):
		self._y = value
	
	# constructor - ModuleA_SomePoint
	def __init__(self,
			x: Optional[float] = None,
			y: Optional[float] = None,
			):
		self._x = x
		self._y = y
		pass
	
	# serialization
	@classmethod
	def from_dict(cls, data: dict) -> 'ModuleA_SomePoint':
		return cls(**data).after_serialize_in()
	
	@classmethod
	def from_pb_msg(cls, pb_msg: Any) -> 'ModuleA_SomePoint':
		data = ModelBase.dict_from_pb_message(pb_msg)
		return cls(**data).after_serialize_in()
				   
	def after_serialize_in(self) -> 'ModuleA_SomePoint':
		return self
	
	def clone(self) -> 'ModuleA_SomePoint':
		return ModuleA_SomePoint.from_dict(self.to_dict())
	pass
	
### message: module_a.BasicMessageA
class ModuleA_BasicMessageA(ModelBase):
	CLASS_NAME = 'ModuleA_BasicMessageA'
	
	# protobuf names
	PB_NAME = 'name'
	PB_INT_VALUE = 'int_value'
	PB_FLOAT_VALUE = 'float_value'
	PB_BOOL_VALUE = 'bool_value'
	PB_ENUM_VALUE = 'enum_value'
	PB_REPEATED_FIELD = 'repeated_field'
	PB_SUB_ITEM = 'sub_item'
	PB_O_NAME = 'o_name'
	PB_O_INT_VALUE = 'o_int_value'
	PB_O_FLOAT_VALUE = 'o_float_value'
	PB_O_BOOL_VALUE = 'o_bool_value'
	PB_O_ENUM_VALUE = 'o_enum_value'
	
	# json / dict names
	NAME = 'name'
	INT_VALUE = 'intValue'
	FLOAT_VALUE = 'floatValue'
	BOOL_VALUE = 'boolValue'
	ENUM_VALUE = 'enumValue'
	REPEATED_FIELD = 'repeatedField'
	SUB_ITEM = 'subItem'
	O_NAME = 'oName'
	O_INT_VALUE = 'oIntValue'
	O_FLOAT_VALUE = 'oFloatValue'
	O_BOOL_VALUE = 'oBoolValue'
	O_ENUM_VALUE = 'oEnumValue'
	
	# property name
	@property
	def name(self) -> Optional[str]:
		return self._name
	@name.setter
	def name(self, value: Optional[str]):
		self._name = value
	
	# property intValue
	@property
	def intValue(self) -> Optional[int]:
		return self._intValue
	@intValue.setter
	def intValue(self, value: Optional[int]):
		self._intValue = value
	
	# property floatValue
	@property
	def floatValue(self) -> Optional[float]:
		return self._floatValue
	@floatValue.setter
	def floatValue(self, value: Optional[float]):
		self._floatValue = value
	
	# property boolValue
	@property
	def boolValue(self) -> Optional[bool]:
		return self._boolValue
	@boolValue.setter
	def boolValue(self, value: Optional[bool]):
		self._boolValue = value
	
	# property enumValue
	@property
	def enumValue(self) -> Optional[ModuleA_BasicEnum]:
		return self._enumValue
	@enumValue.setter
	def enumValue(self, value: Optional[ModuleA_BasicEnum]):
		self._enumValue = value
	
	# property repeatedField
	@property
	def repeatedField(self) -> Optional[List[int]]:
		return self._repeatedField
	@repeatedField.setter
	def repeatedField(self, value: Optional[List[int]]):
		self._repeatedField = value
	
	# property subItem
	@property
	def subItem(self) -> Optional[ModuleA_BasicSubItem]:
		return self._subItem
	@subItem.setter
	def subItem(self, value: Optional[ModuleA_BasicSubItem]):
		self._subItem = value
	
	# property oName
	@property
	def oName(self) -> Optional[str]:
		return self._oName
	@oName.setter
	def oName(self, value: Optional[str]):
		self._oName = value
	
	# property oIntValue
	@property
	def oIntValue(self) -> Optional[int]:
		return self._oIntValue
	@oIntValue.setter
	def oIntValue(self, value: Optional[int]):
		self._oIntValue = value
	
	# property oFloatValue
	@property
	def oFloatValue(self) -> Optional[float]:
		return self._oFloatValue
	@oFloatValue.setter
	def oFloatValue(self, value: Optional[float]):
		self._oFloatValue = value
	
	# property oBoolValue
	@property
	def oBoolValue(self) -> Optional[bool]:
		return self._oBoolValue
	@oBoolValue.setter
	def oBoolValue(self, value: Optional[bool]):
		self._oBoolValue = value
	
	# property oEnumValue
	@property
	def oEnumValue(self) -> Optional[ModuleA_BasicEnum]:
		return self._oEnumValue
	@oEnumValue.setter
	def oEnumValue(self, value: Optional[ModuleA_BasicEnum]):
		self._oEnumValue = value
	
	# constructor - ModuleA_BasicMessageA
	def __init__(self,
			name: Optional[str] = None,
			intValue: Optional[int] = None,
			floatValue: Optional[float] = None,
			boolValue: Optional[bool] = None,
			enumValue: Optional[ModuleA_BasicEnum] = None,
			repeatedField: Optional[List[int]] = None,
			subItem: Optional[ModuleA_BasicSubItem] = None,
			oName: Optional[str] = None,
			oIntValue: Optional[int] = None,
			oFloatValue: Optional[float] = None,
			oBoolValue: Optional[bool] = None,
			oEnumValue: Optional[ModuleA_BasicEnum] = None,
			):
		self._name = name
		self._intValue = intValue
		self._floatValue = floatValue
		self._boolValue = boolValue
		self._enumValue = enumValue
		self._repeatedField = repeatedField
		self._subItem = subItem
		self._oName = oName
		self._oIntValue = oIntValue
		self._oFloatValue = oFloatValue
		self._oBoolValue = oBoolValue
		self._oEnumValue = oEnumValue
		pass
	
	# serialization
	@classmethod
	def from_dict(cls, data: dict) -> 'ModuleA_BasicMessageA':
		return cls(**data).after_serialize_in()
	
	@classmethod
	def from_pb_msg(cls, pb_msg: Any) -> 'ModuleA_BasicMessageA':
		data = ModelBase.dict_from_pb_message(pb_msg)
		return cls(**data).after_serialize_in()
				   
	def after_serialize_in(self) -> 'ModuleA_BasicMessageA':
		if self.enumValue is not None:
			self.enumValue = ModuleA_BasicEnum(self.enumValue)
		if self.oEnumValue is not None:
			self.oEnumValue = ModuleA_BasicEnum(self.oEnumValue)
		if self.subItem is not None:
			raw: Any = self.subItem
			self.subItem = ModuleA_BasicSubItem(**raw).after_serialize_in()
		return self
	
	def clone(self) -> 'ModuleA_BasicMessageA':
		return ModuleA_BasicMessageA.from_dict(self.to_dict())
	pass
	
### message: module_a.MsgWithRepeatedProps
class ModuleA_MsgWithRepeatedProps(ModelBase):
	CLASS_NAME = 'ModuleA_MsgWithRepeatedProps'
	
	# protobuf names
	PB_TXT = 'txt'
	PB_LINES = 'lines'
	PB_ENUMS = 'enums'
	PB_POINTS = 'points'
	
	# json / dict names
	TXT = 'txt'
	LINES = 'lines'
	ENUMS = 'enums'
	POINTS = 'points'
	
	# property txt
	@property
	def txt(self) -> Optional[str]:
		return self._txt
	@txt.setter
	def txt(self, value: Optional[str]):
		self._txt = value
	
	# property lines
	@property
	def lines(self) -> Optional[List[str]]:
		return self._lines
	@lines.setter
	def lines(self, value: Optional[List[str]]):
		self._lines = value
	
	# property enums
	@property
	def enums(self) -> Optional[List[ModuleA_BasicEnum]]:
		return self._enums
	@enums.setter
	def enums(self, value: Optional[List[ModuleA_BasicEnum]]):
		self._enums = value
	
	# property points
	@property
	def points(self) -> Optional[List[ModuleA_SomePoint]]:
		return self._points
	@points.setter
	def points(self, value: Optional[List[ModuleA_SomePoint]]):
		self._points = value
	
	# constructor - ModuleA_MsgWithRepeatedProps
	def __init__(self,
			txt: Optional[str] = None,
			lines: Optional[List[str]] = None,
			enums: Optional[List[ModuleA_BasicEnum]] = None,
			points: Optional[List[ModuleA_SomePoint]] = None,
			):
		self._txt = txt
		self._lines = lines
		self._enums = enums
		self._points = points
		pass
	
	# serialization
	@classmethod
	def from_dict(cls, data: dict) -> 'ModuleA_MsgWithRepeatedProps':
		return cls(**data).after_serialize_in()
	
	@classmethod
	def from_pb_msg(cls, pb_msg: Any) -> 'ModuleA_MsgWithRepeatedProps':
		data = ModelBase.dict_from_pb_message(pb_msg)
		return cls(**data).after_serialize_in()
				   
	def after_serialize_in(self) -> 'ModuleA_MsgWithRepeatedProps':
		if self.enums is not None:
			values = cast(List[str], self.enums) 
			self.enums = [ModuleA_BasicEnum(value) for value in values]
		if self.points is not None:
			values = cast(List[Any], self.points) 
			self.points = [ModuleA_SomePoint(**value).after_serialize_in() for value in values]
		return self
	
	def clone(self) -> 'ModuleA_MsgWithRepeatedProps':
		return ModuleA_MsgWithRepeatedProps.from_dict(self.to_dict())
	pass
	
### message: module_a.MsgWithOneOfProps
class ModuleA_MsgWithOneOfProps(ModelBase):
	CLASS_NAME = 'ModuleA_MsgWithOneOfProps'
	
	# protobuf names
	PB_TXT = 'txt'
	PB_POINT_A = 'point_a'
	PB_POINT_B = 'point_b'
	
	# json / dict names
	TXT = 'txt'
	POINT_A = 'pointA'
	POINT_B = 'pointB'
	
	# property txt
	@property
	def txt(self) -> Optional[str]:
		return self._txt
	@txt.setter
	def txt(self, value: Optional[str]):
		self._txt = value
	
	# property pointA
	@property
	def pointA(self) -> Optional[ModuleA_SomePoint]:
		return self._pointA
	@pointA.setter
	def pointA(self, value: Optional[ModuleA_SomePoint]):
		self._pointA = value
		self._pointB = None
	
	# property pointB
	@property
	def pointB(self) -> Optional[ModuleA_SomePoint]:
		return self._pointB
	@pointB.setter
	def pointB(self, value: Optional[ModuleA_SomePoint]):
		self._pointA = None
		self._pointB = value
	
	# constructor - ModuleA_MsgWithOneOfProps
	def __init__(self,
			txt: Optional[str] = None,
			pointA: Optional[ModuleA_SomePoint] = None,
			pointB: Optional[ModuleA_SomePoint] = None,
			):
		self._txt = txt
		self._pointA = pointA
		self._pointB = pointB
		pass
	
	# serialization
	@classmethod
	def from_dict(cls, data: dict) -> 'ModuleA_MsgWithOneOfProps':
		return cls(**data).after_serialize_in()
	
	@classmethod
	def from_pb_msg(cls, pb_msg: Any) -> 'ModuleA_MsgWithOneOfProps':
		data = ModelBase.dict_from_pb_message(pb_msg)
		return cls(**data).after_serialize_in()
				   
	def after_serialize_in(self) -> 'ModuleA_MsgWithOneOfProps':
		if self.pointA is not None:
			raw: Any = self.pointA
			self.pointA = ModuleA_SomePoint(**raw).after_serialize_in()
		if self.pointB is not None:
			raw: Any = self.pointB
			self.pointB = ModuleA_SomePoint(**raw).after_serialize_in()
		return self
	
	def clone(self) -> 'ModuleA_MsgWithOneOfProps':
		return ModuleA_MsgWithOneOfProps.from_dict(self.to_dict())
	pass
	
### message: module_a.MsgWithSet
class ModuleA_MsgWithSet(ModelBase):
	CLASS_NAME = 'ModuleA_MsgWithSet'
	
	# protobuf names
	PB_ITEM = 'item'
	PB_A_STRING_MAP = 'a_string_map'
	PB_ITEMS_MAP = 'items_map'
	
	# json / dict names
	ITEM = 'item'
	A_STRING_MAP = 'aStringMap'
	ITEMS_MAP = 'itemsMap'
	
	# property item
	@property
	def item(self) -> Optional[ModuleB_ItemB]:
		return self._item
	@item.setter
	def item(self, value: Optional[ModuleB_ItemB]):
		self._item = value
	
	# property aStringMap
	@property
	def aStringMap(self) -> Optional[Dict[str, str]]:
		return self._aStringMap
	@aStringMap.setter
	def aStringMap(self, value: Optional[Dict[str, str]]):
		self._aStringMap = value
	
	# property itemsMap
	@property
	def itemsMap(self) -> Optional[Dict[str, ModuleB_ItemB]]:
		return self._itemsMap
	@itemsMap.setter
	def itemsMap(self, value: Optional[Dict[str, ModuleB_ItemB]]):
		self._itemsMap = value
	
	# constructor - ModuleA_MsgWithSet
	def __init__(self,
			item: Optional[ModuleB_ItemB] = None,
			aStringMap: Optional[Dict[str, str]] = None,
			itemsMap: Optional[Dict[str, ModuleB_ItemB]] = None,
			):
		self._item = item
		self._aStringMap = aStringMap
		self._itemsMap = itemsMap
		pass
	
	# serialization
	@classmethod
	def from_dict(cls, data: dict) -> 'ModuleA_MsgWithSet':
		return cls(**data).after_serialize_in()
	
	@classmethod
	def from_pb_msg(cls, pb_msg: Any) -> 'ModuleA_MsgWithSet':
		data = ModelBase.dict_from_pb_message(pb_msg)
		return cls(**data).after_serialize_in()
				   
	def after_serialize_in(self) -> 'ModuleA_MsgWithSet':
		if self.item is not None:
			raw: Any = self.item
			self.item = ModuleB_ItemB(**raw).after_serialize_in()
		if self.aStringMap is not None:
			pass
		if self.itemsMap is not None:
			newmap = {}
			for key, value in self.itemsMap.items():
				raw: Any = value
				newmap[key] = ModuleB_ItemB(**raw).after_serialize_in()
			self.itemsMap = newmap
		return self
	
	def clone(self) -> 'ModuleA_MsgWithSet':
		return ModuleA_MsgWithSet.from_dict(self.to_dict())
	pass
	
### message: module_a.MsgWithTimestamp
class ModuleA_MsgWithTimestamp(ModelBase):
	CLASS_NAME = 'ModuleA_MsgWithTimestamp'
	
	# protobuf names
	PB_SOME_TIMESTAMP = 'some_timestamp'
	PB_SOME_VALUE = 'some_value'
	
	# json / dict names
	SOME_TIMESTAMP = 'someTimestamp'
	SOME_VALUE = 'someValue'
	
	# property someTimestamp
	@property
	def someTimestamp(self) -> Optional[Google_Timestamp]:
		return self._someTimestamp
	@someTimestamp.setter
	def someTimestamp(self, value: Optional[Google_Timestamp]):
		self._someTimestamp = value
	
	# property someValue
	@property
	def someValue(self) -> Optional[int]:
		return self._someValue
	@someValue.setter
	def someValue(self, value: Optional[int]):
		self._someValue = value
	
	# constructor - ModuleA_MsgWithTimestamp
	def __init__(self,
			someTimestamp: Optional[Google_Timestamp] = None,
			someValue: Optional[int] = None,
			):
		self._someTimestamp = someTimestamp
		self._someValue = someValue
		pass
	
	# serialization
	@classmethod
	def from_dict(cls, data: dict) -> 'ModuleA_MsgWithTimestamp':
		return cls(**data).after_serialize_in()
	
	@classmethod
	def from_pb_msg(cls, pb_msg: Any) -> 'ModuleA_MsgWithTimestamp':
		data = ModelBase.dict_from_pb_message(pb_msg)
		return cls(**data).after_serialize_in()
				   
	def after_serialize_in(self) -> 'ModuleA_MsgWithTimestamp':
		if self.someTimestamp is not None:
			raw: Any = self.someTimestamp
			self.someTimestamp = Google_Timestamp(raw)
		return self
	
	def clone(self) -> 'ModuleA_MsgWithTimestamp':
		return ModuleA_MsgWithTimestamp.from_dict(self.to_dict())
	pass
	
### message: module_b.ItemB
class ModuleB_ItemB(ModelBase):
	CLASS_NAME = 'ModuleB_ItemB'
	
	# protobuf names
	PB_ID = 'id'
	
	# json / dict names
	ID = 'id'
	
	# property id
	@property
	def id(self) -> Optional[int]:
		return self._id
	@id.setter
	def id(self, value: Optional[int]):
		self._id = value
	
	# constructor - ModuleB_ItemB
	def __init__(self,
			id: Optional[int] = None,
			):
		self._id = id
		pass
	
	# serialization
	@classmethod
	def from_dict(cls, data: dict) -> 'ModuleB_ItemB':
		return cls(**data).after_serialize_in()
	
	@classmethod
	def from_pb_msg(cls, pb_msg: Any) -> 'ModuleB_ItemB':
		data = ModelBase.dict_from_pb_message(pb_msg)
		return cls(**data).after_serialize_in()
				   
	def after_serialize_in(self) -> 'ModuleB_ItemB':
		return self
	
	def clone(self) -> 'ModuleB_ItemB':
		return ModuleB_ItemB.from_dict(self.to_dict())
	pass
	
### message: module_b.BasicMessageB
class ModuleB_BasicMessageB(ModelBase):
	CLASS_NAME = 'ModuleB_BasicMessageB'
	
	# protobuf names
	PB_NAME = 'name'
	
	# json / dict names
	NAME = 'name'
	
	# property name
	@property
	def name(self) -> Optional[str]:
		return self._name
	@name.setter
	def name(self, value: Optional[str]):
		self._name = value
	
	# constructor - ModuleB_BasicMessageB
	def __init__(self,
			name: Optional[str] = None,
			):
		self._name = name
		pass
	
	# serialization
	@classmethod
	def from_dict(cls, data: dict) -> 'ModuleB_BasicMessageB':
		return cls(**data).after_serialize_in()
	
	@classmethod
	def from_pb_msg(cls, pb_msg: Any) -> 'ModuleB_BasicMessageB':
		data = ModelBase.dict_from_pb_message(pb_msg)
		return cls(**data).after_serialize_in()
				   
	def after_serialize_in(self) -> 'ModuleB_BasicMessageB':
		return self
	
	def clone(self) -> 'ModuleB_BasicMessageB':
		return ModuleB_BasicMessageB.from_dict(self.to_dict())
	pass
	