from __future__ import annotations
from typing import Optional, List, Any
from dataclasses import dataclass, asdict
from enum import Enum
"""
    auto generated file, model classes generated from protobuf classes
    
    example of usage:
    
    from google.protobuf.json_format import MessageToDict
    # proto buf message
    pbMsg = pb2.MyMessage(...)
    # convert to autogenerated Model object
    modelMsg = ModelMyMessage.from_dict(MessageToDict(pbMsg))
"""

MODEL_VERSION = '0.0.1'


@dataclass
class ModelBase():
    def to_dict(self) -> Any:
        return self._to_dict(asdict(self))
    
    def _to_dict(self, obj) -> Any:
        # return enum name, not value
        if isinstance(obj, Enum):
            return obj.name
        # remove None values
        if isinstance(obj, list):
            return [self._to_dict(item) for item in obj if item is not None]
        if isinstance(obj, dict):
            return {key: self._to_dict(value) for key, value in obj.items() if value is not None }
        else:
            return obj
        
    def after_serialize_in(self) -> Any:
        return self
        
                   
class ModelBasicEnum(Enum):
	UNKNOWN = 'UNKNOWN'
	VALUE_1 = 'VALUE_1'
	ABC = 'ABC'
	LOWER_CASE_VALUE = 'lower_case_value'

@dataclass
class ModelBasicSubItem(ModelBase):
	
	CLASS_NAME = 'ModelBasicSubItem'
	NAME = 'name'
	SINGLEPOINT = 'singlePoint'
	
	name: Optional[str] = None
	singlePoint: Optional[ModelSomePoint] = None
	
	@classmethod
	def from_dict(cls, data: dict) -> 'ModelBasicSubItem':
		return cls(**data).after_serialize_in()
	
	def after_serialize_in(self) -> 'ModelBasicSubItem':
		if self.singlePoint is not None:
			raw: Any = self.singlePoint
			self.singlePoint = ModelSomePoint(**raw).after_serialize_in()
		return self
	
	def clone(self) -> 'ModelBasicSubItem':
		return ModelBasicSubItem.from_dict(self.to_dict())
	pass
	
@dataclass
class ModelSomePoint(ModelBase):
	
	CLASS_NAME = 'ModelSomePoint'
	X = 'x'
	Y = 'y'
	
	x: Optional[float] = None
	y: Optional[float] = None
	
	@classmethod
	def from_dict(cls, data: dict) -> 'ModelSomePoint':
		return cls(**data).after_serialize_in()
	
	def after_serialize_in(self) -> 'ModelSomePoint':
		return self
	
	def clone(self) -> 'ModelSomePoint':
		return ModelSomePoint.from_dict(self.to_dict())
	pass
	
@dataclass
class ModelBasicMessageA(ModelBase):
	
	CLASS_NAME = 'ModelBasicMessageA'
	NAME = 'name'
	INTVALUE = 'intValue'
	FLOATVALUE = 'floatValue'
	BOOLVALUE = 'boolValue'
	ENUMVALUE = 'enumValue'
	REPEATEDFIELD = 'repeatedField'
	SUBITEM = 'subItem'
	ONAME = 'oName'
	OINTVALUE = 'oIntValue'
	OFLOATVALUE = 'oFloatValue'
	OBOOLVALUE = 'oBoolValue'
	OENUMVALUE = 'oEnumValue'
	
	name: Optional[str] = None
	intValue: Optional[int] = None
	floatValue: Optional[float] = None
	boolValue: Optional[bool] = None
	enumValue: Optional[ModelBasicEnum] = None
	repeatedField: Optional[List[int]] = None
	subItem: Optional[ModelBasicSubItem] = None
	oName: Optional[str] = None
	oIntValue: Optional[int] = None
	oFloatValue: Optional[float] = None
	oBoolValue: Optional[bool] = None
	oEnumValue: Optional[ModelBasicEnum] = None
	
	@classmethod
	def from_dict(cls, data: dict) -> 'ModelBasicMessageA':
		return cls(**data).after_serialize_in()
	
	def after_serialize_in(self) -> 'ModelBasicMessageA':
		if self.enum_value is not None:
			self.enum_value = ModelBasicEnum(self.enum_value)
		if self.o_enum_value is not None:
			self.o_enum_value = ModelBasicEnum(self.o_enum_value)
		if self.sub_item is not None:
			raw: Any = self.sub_item
			self.sub_item = ModelBasicSubItem(**raw).after_serialize_in()
		return self
	
	def clone(self) -> 'ModelBasicMessageA':
		return ModelBasicMessageA.from_dict(self.to_dict())
	pass
	
@dataclass
class ModelBasicMessageB(ModelBase):
	
	CLASS_NAME = 'ModelBasicMessageB'
	NAME = 'name'
	
	name: Optional[str] = None
	
	@classmethod
	def from_dict(cls, data: dict) -> 'ModelBasicMessageB':
		return cls(**data).after_serialize_in()
	
	def after_serialize_in(self) -> 'ModelBasicMessageB':
		return self
	
	def clone(self) -> 'ModelBasicMessageB':
		return ModelBasicMessageB.from_dict(self.to_dict())
	pass
	